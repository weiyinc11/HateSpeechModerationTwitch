import { __decorate } from "tslib";
import getRawBody from '@d-fischer/raw-body';
import { Enumerable } from '@d-fischer/shared-utils';
import { InvalidTokenTypeError } from '@twurple/auth';
import { EventSubBase } from '@twurple/eventsub-base';
import * as crypto from 'crypto';
/**
 * @private
 * @hideProtected
 */
export class EventSubHttpBase extends EventSubBase {
    constructor(config) {
        var _a;
        if (config.apiClient._authProvider.tokenType !== 'app') {
            throw new InvalidTokenTypeError('EventSub over HTTP requires app access tokens to work; please use the ClientCredentialsAuthProvider in your API client.');
        }
        // catch the examples copied verbatim
        if (!config.secret || config.secret === 'thisShouldBeARandomlyGeneratedFixedString') {
            throw new Error('Please generate a secret and pass it to the constructor!');
        }
        super(config);
        this._seenEventIds = new Set();
        /**
         * Fires when a subscription is successfully verified or fails to verify.
         *
         * @eventListener
         *
         * @param success Whether the verification succeeded.
         * @param subscription The subscription that was verified.
         */
        this.onVerify = this.registerEvent();
        this._secret = config.secret;
        if (config.strictHostCheck === undefined) {
            this._logger
                .warn(`A new option named \`strictHostCheck\` was introduced in order to ignore access to your handler by wide-range vulnerability scanners (and thus dropping all the log messages caused by them).
Its default value is \`false\` for now, but will change to \`true\` in the next major release.
To enable this check and silence this warning, please add \`strictHostCheck: true\` to your EventSub configuration.
To silence this warning without enabling this check (and thus to keep it off even after a major release), please add \`strictHostCheck: false\` to your EventSub configuration.`);
        }
        this._strictHostCheck = (_a = config.strictHostCheck) !== null && _a !== void 0 ? _a : false;
    }
    /** @private */
    async _buildHookUrl(id) {
        var _a;
        const hostName = await this.getHostName();
        // trim slashes on both ends
        const pathPrefix = (_a = (await this.getPathPrefix())) === null || _a === void 0 ? void 0 : _a.replace(/^\/|\/$/, '');
        return `https://${hostName}${pathPrefix ? '/' : ''}${pathPrefix !== null && pathPrefix !== void 0 ? pathPrefix : ''}/event/${id}`;
    }
    /** @private */
    async _getTransportOptionsForSubscription(subscription) {
        return {
            method: 'webhook',
            callback: await this._buildHookUrl(subscription.id),
            secret: this._createSecretForSubscription(subscription)
        };
    }
    /** @private */
    async _getCliTestCommandForSubscription(subscription) {
        return `twitch event trigger ${subscription._cliName} -F ${await this._buildHookUrl(subscription.id)} -s ${this._createSecretForSubscription(subscription)}`;
    }
    async _resumeExistingSubscriptions() {
        const subscriptions = await this._apiClient.eventSub.getSubscriptionsPaginated().getAll();
        const urlPrefix = await this._buildHookUrl('');
        this._twitchSubscriptions = new Map(subscriptions
            .map((sub) => {
            // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
            if (sub._transport.method === 'webhook') {
                const url = sub._transport.callback;
                if (url.startsWith(urlPrefix)) {
                    const id = url.slice(urlPrefix.length);
                    return [id, sub];
                }
            }
            return undefined;
        })
            .filter((x) => !!x));
        await Promise.all([...this._subscriptions].map(async ([subId, sub]) => await sub.start(this._twitchSubscriptions.get(subId))));
    }
    _createHandleRequest() {
        return async (req, res, next) => {
            if (req.readableEnded) {
                throw new Error('The request body was already consumed by something else.\n' +
                    "Please make sure you don't globally apply middlewares that consume the request body, " +
                    'such as express.json() or body-parser.');
            }
            if (await this._isHostDenied(req)) {
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(404);
                res.end('Not OK');
                return;
            }
            // The HTTP listener intentionally does not use the built-in resolution by Twitch subscription ID
            // to be able to recognize subscriptions from the URL (for avoiding unnecessary re-subscribing)
            const { id } = req.params;
            const subscription = this._subscriptions.get(id);
            const twitchSubscription = this._twitchSubscriptions.get(id);
            const type = req.headers['twitch-eventsub-message-type'];
            if (!subscription) {
                this._logger.warn(`Action ${type} of unknown event attempted: ${id}`);
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(410);
                res.end('Not OK');
                return;
            }
            const messageId = req.headers['twitch-eventsub-message-id'];
            const timestamp = req.headers['twitch-eventsub-message-timestamp'];
            const body = await getRawBody(req, true);
            const algoAndSignature = req.headers['twitch-eventsub-message-signature'];
            if (algoAndSignature === undefined) {
                this._logger.warn(`Dropping unsigned message for action ${type} of event: ${id}`);
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(410);
                res.end('Not OK');
                return;
            }
            const verified = this._verifyData(subscription, messageId, timestamp, body, algoAndSignature);
            const data = JSON.parse(body);
            if (!verified) {
                this._logger.warn(`Could not verify action ${type} of event: ${id}`);
                if (type === 'webhook_callback_verification') {
                    this.emit(this.onVerify, false, subscription);
                }
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(410);
                res.end('Not OK');
                return;
            }
            if (type === 'webhook_callback_verification') {
                const verificationBody = data;
                this.emit(this.onVerify, true, subscription);
                subscription._verify();
                if (twitchSubscription) {
                    twitchSubscription._status = 'enabled';
                }
                res.setHeader('Content-Length', verificationBody.challenge.length);
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(200, undefined);
                res.end(verificationBody.challenge);
                this._logger.debug(`Successfully subscribed to event: ${id}`);
            }
            else if (type === 'notification') {
                if (this._seenEventIds.has(messageId)) {
                    this._logger.debug(`Duplicate notification prevented for event: ${id}`);
                }
                else if (new Date(timestamp).getTime() < Date.now() - 10 * 60 * 1000) {
                    this._logger.debug(`Old notification prevented for event: ${id}`);
                }
                else {
                    this._seenEventIds.add(messageId);
                    setTimeout(() => this._seenEventIds.delete(messageId), 10 * 60 * 1000);
                    subscription._handleData(data.event);
                }
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(202);
                res.end('OK');
            }
            else if (type === 'revocation') {
                this._dropSubscription(subscription.id);
                this._dropTwitchSubscription(subscription.id);
                this.emit(this.onRevoke, subscription);
                this._logger.debug(`Subscription revoked by Twitch for event: ${id}`);
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(202);
                res.end('OK');
            }
            else {
                this._logger.warn(`Unknown action ${type} for event: ${id}`);
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(400);
                res.end('Not OK');
            }
            next();
        };
    }
    _createDropLegacyRequest() {
        return async (req, res, next) => {
            if (await this._isHostDenied(req)) {
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(404);
                res.end('Not OK');
                return;
            }
            const twitchSub = this._twitchSubscriptions.get(req.params.id);
            if (twitchSub) {
                await this._apiClient.eventSub.deleteSubscription(twitchSub.id);
                this._logger.debug(`Dropped legacy subscription for event: ${req.params.id}`);
                res.setHeader('Content-Type', 'text/plain');
                res.writeHead(410);
                res.end('Not OK');
            }
            else {
                next();
            }
        };
    }
    _createHandleHealthRequest() {
        return async (req, res) => {
            res.setHeader('Content-Type', 'text/plain');
            if (await this._isHostDenied(req)) {
                res.writeHead(404);
                res.end('Not OK');
                return;
            }
            res.writeHead(200);
            res.end('@twurple/eventsub-http is listening here');
        };
    }
    async _isHostDenied(req) {
        if (this._strictHostCheck) {
            const ip = req.socket.remoteAddress;
            if (ip === undefined) {
                // client disconnected already
                return true;
            }
            if (ip === '127.0.0.1' || ip === '::1' || ip === '::ffff:127.0.0.1') {
                // localhost is always fine
                return false;
            }
            const host = req.headers.host;
            if (host === undefined) {
                this._logger.debug(`Denied request from ${ip} because its host header is empty`);
                return true;
            }
            const expectedHost = await this.getHostName();
            if (host !== expectedHost) {
                this._logger.debug(`Denied request from ${ip} because its host header (${host}) doesn't match the expected value (${expectedHost})`);
                return true;
            }
        }
        return false;
    }
    _findTwitchSubscriptionToContinue(subscription) {
        return this._twitchSubscriptions.get(subscription.id);
    }
    _verifyData(subscription, messageId, timestamp, body, algoAndSignature) {
        const [algorithm, signature] = algoAndSignature.split('=', 2);
        const hash = crypto
            .createHmac(algorithm, this._createSecretForSubscription(subscription))
            .update(messageId + timestamp + body)
            .digest('hex');
        return hash === signature;
    }
    _createSecretForSubscription(subscription) {
        return `${subscription.id}.${this._secret}`.slice(-100);
    }
}
__decorate([
    Enumerable(false)
], EventSubHttpBase.prototype, "_seenEventIds", void 0);
__decorate([
    Enumerable(false)
], EventSubHttpBase.prototype, "_secret", void 0);
