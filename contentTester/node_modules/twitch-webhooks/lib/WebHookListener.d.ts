import type { LoggerOptions } from '@d-fischer/logger';
import type { ApiClient, HelixBanEvent, HelixExtensionTransaction, HelixFollow, HelixHypeTrainEvent, HelixModeratorEvent, HelixStream, HelixSubscriptionEvent, HelixUser } from 'twitch';
import type { UserIdResolvable } from 'twitch-common';
import type { ConnectionAdapter } from './Adapters/ConnectionAdapter';
import type { WebHookListenerConfig } from './Adapters/LegacyAdapter';
import type { ConnectCompatibleApp } from './ConnectCompatibleApp';
import type { Subscription } from './Subscriptions/Subscription';
/**
 * Certificate data used to make the listener server SSL capable.
 */
export interface WebHookListenerCertificateConfig {
    /**
     * The private key of your SSL certificate.
     */
    key: string;
    /**
     * Your full SSL certificate chain, including all intermediate certificates.
     */
    cert: string;
}
/**
 * The configuration of a WebHook listener.
 */
export interface WebHookConfig {
    /**
     * Default validity of a WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time.
     * The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    hookValidity?: number;
    /**
     * Options to pass to the logger.
     */
    logger?: Partial<LoggerOptions>;
}
/**
 * A WebHook listener you can track changes in various channel and user data with.
 */
export declare class WebHookListener {
    private _server?;
    private readonly _subscriptions;
    /** @private */ readonly _apiClient: ApiClient;
    private readonly _adapter;
    private readonly _logger;
    private readonly _defaultHookValidity?;
    /**
     * Creates a new WebHook listener.
     *
     * @deprecated Use the normal {@WebHookListener} constructor instead.
     *
     * @param apiClient The ApiClient instance to use for user info and API requests.
     * @param config
     */
    static create(apiClient: ApiClient, config?: WebHookListenerConfig): Promise<WebHookListener>;
    /**
     * Creates a new WebHook listener.
     *
     * @param apiClient The ApiClient instance to use for user info and API requests.
     * @param adapter The connection adapter.
     * @param config
     */
    constructor(apiClient: ApiClient, adapter: ConnectionAdapter, config?: WebHookConfig);
    /**
     * Starts the backing server and listens to incoming WebHook notifications.
     */
    listen(): Promise<void>;
    /**
     * Stops the backing server, suspending all active subscriptions.
     */
    unlisten(): Promise<void>;
    /**
     * Applies middleware that handles WebHooks to a connect-compatible app (like express).
     *
     * @param app The app the middleware should be applied to.
     */
    applyMiddleware(app: ConnectCompatibleApp): void;
    /**
     * Subscribes to events representing a user changing a public setting or their email address.
     *
     * @param user The user for which to get notifications about changing a setting.
     * @param handler The function that will be called for any new notifications.
     * @param withEmail Whether to subscribe to email address changes. This requires an additional scope (user:read:email).
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToUserChanges(user: UserIdResolvable, handler: (user: HelixUser) => void, withEmail?: boolean, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing a user being followed by other users.
     *
     * @param user The user for which to get notifications about the users they will be followed by.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToFollowsToUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing a user following other users.
     *
     * @param user The user for which to get notifications about the users they will follow.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToFollowsFromUser(user: UserIdResolvable, handler: (follow: HelixFollow) => void, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing a Hype Train event.
     *
     * @param broadcaster The broadcaster / channel for which to get notifications about the Hype Train events.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToHypeTrainEvents(broadcaster: UserIdResolvable, handler: (hypeTrain: HelixHypeTrainEvent) => void, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing a stream changing, i.e. going live, offline or changing its title or category.
     *
     * @param user The user for which to get notifications about their streams changing.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToStreamChanges(user: UserIdResolvable, handler: (stream?: HelixStream) => void, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing the start or end of a channel subscription.
     *
     * @param broadcaster The user for which to get notifications about subscriptions to their channel.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToSubscriptionEvents(broadcaster: UserIdResolvable, handler: (subscriptionEvent: HelixSubscriptionEvent) => void, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing a ban or unban.
     *
     * @param broadcaster The broadcaster for which to get notifications about bans or unbans in their channel.
     * @param handler The function that will be called for any new notifications.
     * @param user The user that events will be sent for. If not given, events will be sent for all users.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToBanEvents(broadcaster: UserIdResolvable, handler: (banEvent: HelixBanEvent) => void, user?: UserIdResolvable, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to events representing a user gaining or losing moderator privileges in a channel.
     *
     * @param broadcaster The broadcaster for which to get notifications about moderator changes in their channel.
     * @param handler The function that will be called for any new notifications.
     * @param user The user that events will be sent for. If not given, events will be sent for all users.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToModeratorEvents(broadcaster: UserIdResolvable, handler: (modEvent: HelixModeratorEvent) => void, user?: UserIdResolvable, validityInSeconds?: number | undefined): Promise<Subscription>;
    /**
     * Subscribes to extension transactions.
     *
     * @param extensionId The extension ID for which to get notifications about transactions.
     * @param handler The function that will be called for any new notifications.
     * @param validityInSeconds The validity of the WebHook, in seconds.
     *
     * Please note that this doesn't mean that you don't get any notifications after the given time. The hook will be automatically refreshed.
     *
     * This is meant for debugging issues. Please don't set it unless you know what you're doing.
     */
    subscribeToExtensionTransactions(extensionId: string, handler: (transaction: HelixExtensionTransaction) => void, validityInSeconds?: number | undefined): Promise<Subscription>;
    /** @private */
    _buildHookUrl(id: string): Promise<string>;
    /** @private */
    _changeIdOfSubscription(oldId: string, newId: string): void;
    /** @private */
    _dropSubscription(id: string): void;
    private _genericSubscribe;
    private _createHandleRequest;
    private _handleVerification;
    private _handleNotification;
}
